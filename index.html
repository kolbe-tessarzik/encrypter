<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Encrypter</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  :root {
    --bg: #0f172a; --surface: #1e293b; --border: #334155;
    --text: #f1f5f9; --text-dim: #94a3b8; --accent: #3b82f6;
    --accent-hover: #2563eb; --success: #10b981;
  }
  body {
    font-family: -apple-system, sans-serif;
    background: var(--bg); color: var(--text);
    min-height: 100vh; display: flex; flex-direction: column; padding: 2rem;
  }
  .container { max-width: 1200px; width: 100%; margin: 0 auto; }
  header { margin-bottom: 3rem; text-align: center; }
  h1 {
    font-size: 2.5rem; font-weight: 700;
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .key-section {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px; padding: 1.5rem; margin-bottom: 2rem;
  }
  .key-label {
    display: block; font-size: 0.875rem; font-weight: 600;
    color: var(--text-dim); margin-bottom: 0.75rem; text-transform: uppercase;
  }
  input[type="text"] {
    width: 100%; padding: 0.875rem 1rem; background: var(--bg);
    border: 1px solid var(--border); border-radius: 8px; color: var(--text);
  }
  .editor-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 2rem; }
  .editor-panel { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; overflow: hidden; }
  .editor-header { padding: 1rem 1.25rem; background: rgba(59, 130, 246, 0.05); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; }
  .editor-title { font-size: 0.875rem; font-weight: 600; }
  textarea {
    width: 100%; height: 400px; padding: 1.25rem; font-family: monospace;
    background: var(--bg); border: none; color: var(--text); resize: vertical;
  }
  #encrypted { color: var(--success); }
  .stats-bar {
    background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
    padding: 1.25rem; display: flex; justify-content: center; gap: 2rem;
  }
  .stat { display: flex; flex-direction: column; align-items: center; }
  .stat-label { font-size: 0.75rem; color: var(--text-dim); }
  .stat-value { font-size: 1.5rem; font-weight: 700; }
  .positive { color: var(--success); }
  @media (max-width: 768px) { .editor-grid { grid-template-columns: 1fr; } }
</style>
</head>
<body>

<div class="container">
  <header><h1>Encrypter</h1></header>
  <div class="key-section">
    <label class="key-label">Encryption Key</label>
    <input type="text" id="key" placeholder="Enter password...">
  </div>
  <div class="editor-grid">
    <div class="editor-panel">
      <div class="editor-header"><span class="editor-title">Original</span><span id="originalCount">0</span></div>
      <textarea id="original"></textarea>
    </div>
    <div class="editor-panel">
      <div class="editor-header"><span class="editor-title">Encrypted</span><span id="encryptedCount">0</span></div>
      <textarea id="encrypted"></textarea>
    </div>
  </div>
  <div class="stats-bar">
    <div class="stat"><span class="stat-label">Compression</span><span id="compressionValue" class="stat-value">0%</span></div>
    <div class="stat"><span class="stat-label">Reduction</span><span id="reductionValue" class="stat-value">0</span></div>
  </div>
</div>

<script>
const originalBox = document.getElementById("original");
const encryptedBox = document.getElementById("encrypted");
const keyBox = document.getElementById("key");
const originalCount = document.getElementById("originalCount");
const encryptedCount = document.getElementById("encryptedCount");
const compressionValue = document.getElementById("compressionValue");
const reductionValue = document.getElementById("reductionValue");

const normalAlphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,!?:;'\"-_=+()[]{}<>/@#$%&*\\|^~`\n";
let dictionaryPatterns = [];
let allSymbols = [];
let dictToSymbol = {}, symbolToDict = {}, singleCharMap = {}, singleCharReverseMap = {};
let isUpdating = false;

async function init() {
  try {
    const response = await fetch('dictionary.json');
    dictionaryPatterns = await response.json();

    // Sort by length descending so longest patterns match first
    dictionaryPatterns.sort((a, b) => b.length - a.length);

    generateSymbols();       // create your 8,000+ symbols
    buildDictionaryMappings(); // map patterns and single chars

    originalBox.addEventListener("input", updateFromOriginal);
    encryptedBox.addEventListener("input", updateFromEncrypted);
    keyBox.addEventListener("input", updateFromOriginal);

    console.log("Dictionary loaded and sorted successfully.");
  } catch (e) {
    console.error("Failed to load dictionary.json. Ensure you are running on a local server.", e);
  }
}


function generateSymbols() {
  const syms = [];

  // Private Use Area (0xE000–0xF8FF) = 6,400 chars
  for (let i = 0xE000; i <= 0xF8FF; i++) syms.push(String.fromCharCode(i));

  // Mathematical Operators (0x2200–0x22FF) = 256 chars
  for (let i = 0x2200; i <= 0x22FF; i++) syms.push(String.fromCharCode(i));

  // Geometric Shapes (0x25A0–0x25FF) = 96 chars
  for (let i = 0x25A0; i <= 0x25FF; i++) syms.push(String.fromCharCode(i));

  // Miscellaneous Technical (0x2300–0x23FF) = 256 chars
  for (let i = 0x2300; i <= 0x23FF; i++) syms.push(String.fromCharCode(i));

  // Miscellaneous Symbols (0x2600–0x26FF) = 256 chars
  for (let i = 0x2600; i <= 0x26FF; i++) syms.push(String.fromCharCode(i));

  allSymbols = syms;
  console.log("Generated symbols:", allSymbols.length); // should be ~7,500+
}


function buildDictionaryMappings() {
  dictToSymbol = {}; symbolToDict = {};
  dictionaryPatterns.forEach((pattern, i) => {
    if (i < allSymbols.length) {
      dictToSymbol[pattern] = allSymbols[i];
      symbolToDict[allSymbols[i]] = pattern;
    }
  });
  
  singleCharMap = {}; singleCharReverseMap = {};
  for (let i = 0; i < normalAlphabet.length; i++) {
    const symIdx = i + dictionaryPatterns.length;
    if (symIdx < allSymbols.length) {
      singleCharMap[normalAlphabet[i]] = allSymbols[symIdx];
      singleCharReverseMap[allSymbols[symIdx]] = normalAlphabet[i];
    }
  }
}

function makeRngFromKey(key) {
  let hash = 2166136261;
  for (const ch of (key || "default")) {
    hash ^= ch.charCodeAt(0);
    hash = Math.imul(hash, 16777619);
  }
  return () => {
    hash ^= hash << 13; hash ^= hash >> 17; hash ^= hash << 5;
    return (hash >>> 0) / 4294967296;
  };
}

function shuffleWithKey(array, key) {
  const rng = makeRngFromKey(key);
  const a = array.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function shuffleMapping(key) {
  // deterministic shuffle of allSymbols based on key
  const shuffled = shuffleWithKey(allSymbols, key);

  // assign to dictionary patterns
  dictToSymbol = {};
  symbolToDict = {};
  dictionaryPatterns.forEach((p, i) => {
    dictToSymbol[p] = shuffled[i];
    symbolToDict[shuffled[i]] = p;
  });

  // assign the rest to single chars
  singleCharMap = {};
  singleCharReverseMap = {};
  for (let i = 0; i < normalAlphabet.length; i++) {
    singleCharMap[normalAlphabet[i]] = shuffled[i + dictionaryPatterns.length];
    singleCharReverseMap[shuffled[i + dictionaryPatterns.length]] = normalAlphabet[i];
  }
}


function encrypt(text, key) {
  shuffleMapping(key); // deterministic shuffle with key
  let output = [];
  let i = 0;

  while (i < text.length) {
    let match = null;

    // find the longest matching pattern starting at position i
    for (const pattern of dictionaryPatterns) {
      if (text.startsWith(pattern, i)) {
        match = pattern;
        break; // stop at first match because dictionary is sorted longest-first
      }
    }

    if (match) {
      output.push(dictToSymbol[match]);
      i += match.length; // jump over the matched pattern
    } else {
      // fallback to single character map
      output.push(singleCharMap[text[i]] || text[i]);
      i++;
    }
  }

  return output.join('');
}


function decrypt(text, key) {
  shuffleMapping(key);
  return Array.from(text).map(s => symbolToDict[s] || singleCharReverseMap[s] || s).join('');
}

function updateStats() {
  const oLen = originalBox.value.length;
  const eLen = encryptedBox.value.length;
  originalCount.textContent = oLen;
  encryptedCount.textContent = eLen;
  if (oLen > 0) {
    compressionValue.textContent = Math.round((1 - (eLen / oLen)) * 100) + "%";
    reductionValue.textContent = oLen - eLen;
  }
}

function updateFromOriginal() {
  if (isUpdating) return;
  isUpdating = true;
  encryptedBox.value = encrypt(originalBox.value, keyBox.value);
  updateStats();
  isUpdating = false;
}

function updateFromEncrypted() {
  if (isUpdating) return;
  isUpdating = true;
  originalBox.value = decrypt(encryptedBox.value, keyBox.value);
  updateStats();
  isUpdating = false;
}

init();
</script>
</body>
</html>