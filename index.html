<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Encrypter</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  :root {
    --bg: #0f172a;
    --surface: #1e293b;
    --border: #334155;
    --text: #f1f5f9;
    --text-dim: #94a3b8;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --success: #10b981;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    padding: 2rem;
  }

  .container {
    max-width: 1200px;
    width: 100%;
    margin: 0 auto;
  }

  header {
    margin-bottom: 3rem;
    text-align: center;
  }

  h1 {
    font-size: 2.5rem;
    font-weight: 700;
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 0.5rem;
  }

  .subtitle {
    color: var(--text-dim);
    font-size: 1rem;
  }

  .key-section {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 2rem;
  }

  .key-label {
    display: block;
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--text-dim);
    margin-bottom: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.875rem 1rem;
    font-size: 1rem;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    transition: all 0.2s ease;
  }

  input[type="text"]:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .editor-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .editor-panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .editor-header {
    padding: 1rem 1.25rem;
    background: rgba(59, 130, 246, 0.05);
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .editor-title {
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--text);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .editor-count {
    font-size: 0.75rem;
    color: var(--text-dim);
    font-variant-numeric: tabular-nums;
  }

  textarea {
    width: 100%;
    height: 400px;
    padding: 1.25rem;
    font-size: 0.95rem;
    font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
    background: var(--bg);
    border: none;
    color: var(--text);
    resize: vertical;
    line-height: 1.6;
  }

  textarea:focus {
    outline: none;
  }

  textarea::placeholder {
    color: var(--text-dim);
    opacity: 0.5;
  }

  #encrypted {
    color: var(--success);
    background: rgba(16, 185, 129, 0.03);
  }

  .stats-bar {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.25rem 1.5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 2rem;
  }

  .stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
  }

  .stat-label {
    font-size: 0.75rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
  }

  .stat-value.positive {
    color: var(--success);
  }

  .stat-value.negative {
    color: #ef4444;
  }

  .stat-value.neutral {
    color: var(--text-dim);
  }

  @media (max-width: 768px) {
    body {
      padding: 1rem;
    }

    h1 {
      font-size: 2rem;
    }

    .editor-grid {
      grid-template-columns: 1fr;
    }

    .stats-bar {
      flex-direction: column;
      gap: 1rem;
    }
  }
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>Encrypter</h1>
  </header>

  <div class="key-section">
    <label class="key-label" for="key">Encryption Key (Optional)</label>
    <input type="text" id="key" placeholder="Enter a password to encrypt the mapping...">
  </div>

  <div class="editor-grid">
    <div class="editor-panel">
      <div class="editor-header">
        <span class="editor-title">Original Text</span>
        <span class="editor-count" id="originalCount">0 characters</span>
      </div>
      <textarea id="original" placeholder="Type or paste your text here..."></textarea>
    </div>

    <div class="editor-panel">
      <div class="editor-header">
        <span class="editor-title">Encrypted Output</span>
        <span class="editor-count" id="encryptedCount">0 characters</span>
      </div>
      <textarea id="encrypted" placeholder="Symbols will appear here..."></textarea>
    </div>
  </div>
</div>

<script>
const originalBox = document.getElementById("original");
const encryptedBox = document.getElementById("encrypted");
const keyBox = document.getElementById("key");
const originalCount = document.getElementById("originalCount");
const encryptedCount = document.getElementById("encryptedCount");


// Standard Alphabet
const normalAlphabet = 
  "abcdefghijklmnopqrstuvwxyz" +
  "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
  "0123456789" +
  " .,!?:;'\"-_=+()[]{}<>/@#$%&*\\|^~`\n";

// Expanded Dictionary
const baseWords = [
  "of the","in the","to the","for the","on the","at the","from the","with the","by the","and the",
  "that the","is the","as the","was the","are the","it is","there is","there are","this is",
  "it was","I am","you are","we are","they are","he is","she is","I have","you have","we have",
  "they have","I will","you will","we will","they will","do not","does not","did not","is not",
  "are not","was not","were not","have not","has not","had not","will not","would not","should not",
  "could not","cannot","can not","I would","you would","he would","she would","we would","they would",
  "the ","be ","to ","of ","and ","a ","in ","that ","have ","I ","it ","for ","not ","on ","with ",
  "he ","as ","you ","do ","at ","this ","but ","his ","by ","from ","they ","we ","say ","her ","she ",
  "or ","an ","will ","my ","one ","all ","would ","there ","their ","what ","so ","up ","out ","if ",
  "about ","who ","get ","which ","go ","me ","when ","make ","can ","like ","time ","no ","just ","him ",
  "the","be","to","of","and","a","in","that","have","it","for","not","on","with","he","as","you",
  "do","at","this","but","his","by","from","they","we","say","her","she","or","an","will","my","one",
  "all","would","there","their","what","so","up","out","if","about","who","get","which","go","me","when",
  "going","coming","taking","making","getting","seeing","looking","thinking","working","trying",
  "time","person","year","way","day","thing","man","world","life","hand","part","child","eye","woman",
  "good","new","first","last","long","great","little","own","other","old","right","big","high",
  "th","he","in","er","an","re","nd","at","on","nt","ha","es","st","en","ed","to","it","ou","ea","hi",
  "ing ","tion ","ment ","able ","ful ","less ","ly ","ing","tion","ment","able","ful","less","ly",
  "The ","In ","It ","This ","That ","There ","What ","When ","Where ","Why ","How ","Who ",
  "don't","doesn't","didn't","isn't","aren't","wasn't","weren't","haven't","hasn't","hadn't",
  "won't","wouldn't","shouldn't","couldn't","can't","I'm","I've","I'll","you're","you've",
  ". ",", ","; ",": ","! ","? ",
];

let dictionaryPatterns = [];
function addToDict(str) {
  if (!dictionaryPatterns.includes(str)) dictionaryPatterns.push(str);
}
baseWords.forEach(word => addToDict(word));
"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ".split('').forEach(l => addToDict(l + " "));
dictionaryPatterns.sort((a, b) => b.length - a.length);

// Generate Symbol Pool
function generateSymbols() {
  let syms = [];
  for(let i=0x4DC0; i<=0x4DFF; i++) syms.push(String.fromCharCode(i));
  for(let i=0x2801; i<=0x28FF; i++) syms.push(String.fromCharCode(i));
  for(let i=0x4E00; i<=0x4FE0; i+=2) syms.push(String.fromCharCode(i));
  syms.push(..."█▓▒░▌▐▀▄■□▢▣▤▥▦▧▨▩▪▫▬▭▮▯▰▱▲△▴▵▶▷▸▹►▻▼▽▾▿◀◁◂◃◄◅");
  syms.push(..."◆◇◈◊●○◌◎◍◐◑◒◓◔◕◖◗◘◙◚◛◜◝◞◟◠◡◢◣◤◥◦◧◨◩◪◫◬◭◮◯");
  syms.push(..."─━│┃┄┅┆┇┈┉┊┋┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽┾┿╀╁╂╃╄╅╆╇╈╉╊╋");
  syms.push(..."∀∁∂∃∄∅∆∇∈∉∊∋∌∍∎∏∐∑−∓∔∕∖∗∘∙√∛∜∝∞∟∠∡∢∣∤∥∦∧∨∩∪∫∬∭∮∯∰∱∲∳∴∵∶∷∸∹∺∻∼∽∾∿");
  syms.push(..."←↑→↓↔↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏");
  syms.push(..."☀☁☂☃☄★☆☇☈☉☊☋☌☍☎☏☐☑☒☓☔☕☖☗☘☙☚☛☜☝☞☟☠☡☢☣☤☥☦☧☨☩☪☫☬☭☮☯☰☱☲☳☴☵☶☷");
  syms.push(..."✁✂✃✄✅✆✇✈✉✊✋✌✍✎✏✐✑✒✓✔✕✖✗✘✙✚✛✜✝✞✟✠✡✢✣✤✥✦✧✨✩✪✫✬✭✮✯✰✱✲✳✴✵✶✷✸✹✺✻✼✽✾✿❀❁❂❃❄❅❆❇❈❉❊❋");
  for(let i=0x5000; i<=0x51E0; i+=2) syms.push(String.fromCharCode(i));
  for(let i=0x3040; i<=0x309F; i++) syms.push(String.fromCharCode(i));
  for(let i=0x30A0; i<=0x30FF; i++) syms.push(String.fromCharCode(i));
  for(let i=0x0391; i<=0x03C9; i++) syms.push(String.fromCharCode(i));
  return syms;
}

const allSymbols = generateSymbols();
let dictToSymbol = {};
let symbolToDict = {};
let singleCharPool = [];

function initializeMaps() {
  dictToSymbol = {};
  symbolToDict = {};
  let symIndex = 0;
  
  for (let pattern of dictionaryPatterns) {
    if (symIndex < allSymbols.length) {
      const sym = allSymbols[symIndex];
      dictToSymbol[pattern] = sym;
      symbolToDict[sym] = pattern;
      symIndex++;
    }
  }
  
  singleCharPool = allSymbols.slice(symIndex);
}

initializeMaps();

function makeRngFromKey(key) {
  let hash = 2166136261;
  for (const ch of key) {
    hash ^= ch.charCodeAt(0);
    hash = Math.imul(hash, 16777619);
  }
  return function() {
    hash ^= hash << 13; hash ^= hash >> 17; hash ^= hash << 5;
    return (hash >>> 0) / 4294967296;
  }
}

function buildCipher(key) {
  const rng = makeRngFromKey(key || "default-static-seed");
  const a = singleCharPool.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function encrypt(text, key) {
  const shuffledPool = buildCipher(key);
  const shifts = [...(key || "default")].map(c => c.charCodeAt(0));
  let out = "";
  let idx = 0; 
  
  while (idx < text.length) {
    let matchedPattern = null;
    
    for (let pattern of dictionaryPatterns) {
      if (pattern.length > text.length - idx) continue;
      if (text.substr(idx, pattern.length) === pattern) {
        matchedPattern = pattern;
        break;
      }
    }

    if (matchedPattern) {
      out += dictToSymbol[matchedPattern];
      idx += matchedPattern.length;
    } else {
      const ch = text[idx];
      const alphIdx = normalAlphabet.indexOf(ch);
      
      if (alphIdx === -1) {
        out += ch; 
      } else {
        const k = shifts.length ? shifts[idx % shifts.length] : 0;
        const cipherIndex = (alphIdx + k + idx) % shuffledPool.length;
        out += shuffledPool[cipherIndex];
      }
      idx++;
    }
  }
  return out;
}

function decrypt(text, key) {
  const shuffledPool = buildCipher(key);
  const shifts = [...(key || "default")].map(c => c.charCodeAt(0));
  let out = "";
  let idx = 0;
  const symbols = Array.from(text);
  
  for (let s = 0; s < symbols.length; s++) {
    const sym = symbols[s];
    
    if (symbolToDict[sym]) {
      const phrase = symbolToDict[sym];
      out += phrase;
      continue;
    }
    
    const poolIndex = shuffledPool.indexOf(sym);
    if (poolIndex === -1) {
      out += sym;
      idx++;
      continue;
    }
    
    const k = shifts.length ? shifts[idx % shifts.length] : 0;
    let alphIdx = (poolIndex - k - idx) % shuffledPool.length;
    while (alphIdx < 0) alphIdx += shuffledPool.length;
    
    if (alphIdx < normalAlphabet.length) {
      out += normalAlphabet[alphIdx];
    } else {
      out += normalAlphabet[alphIdx % normalAlphabet.length];
    }
    idx++;
  }
  return out;
}

let isUpdating = false;



function updateFromOriginal() {
  if (isUpdating) return;
  isUpdating = true;
  encryptedBox.value = encrypt(originalBox.value, keyBox.value);

  isUpdating = false;
}

function updateFromEncrypted() {
  if (isUpdating) return;
  isUpdating = true;
  originalBox.value = decrypt(encryptedBox.value, keyBox.value);

  isUpdating = false;
}

originalBox.addEventListener("input", updateFromOriginal);
encryptedBox.addEventListener("input", updateFromEncrypted);
keyBox.addEventListener("input", updateFromOriginal);

window.addEventListener('load', () => {
  updateFromOriginal();
});
</script>
</body>
</html>