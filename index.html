<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Encrypter</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  :root {
    --bg: #0f172a;
    --surface: #1e293b;
    --border: #334155;
    --text: #f1f5f9;
    --text-dim: #94a3b8;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --success: #10b981;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    padding: 2rem;
  }

  .container {
    max-width: 1200px;
    width: 100%;
    margin: 0 auto;
  }

  header {
    margin-bottom: 3rem;
    text-align: center;
  }

  h1 {
    font-size: 2.5rem;
    font-weight: 700;
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 0.5rem;
  }

  .subtitle {
    color: var(--text-dim);
    font-size: 1rem;
  }

  .key-section {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 2rem;
  }

  .key-label {
    display: block;
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--text-dim);
    margin-bottom: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  input[type="text"] {
    width: 100%;
    padding: 0.875rem 1rem;
    font-size: 1rem;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    transition: all 0.2s ease;
  }

  input[type="text"]:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .editor-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .editor-panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .editor-header {
    padding: 1rem 1.25rem;
    background: rgba(59, 130, 246, 0.05);
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .editor-title {
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--text);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .editor-count {
    font-size: 0.75rem;
    color: var(--text-dim);
    font-variant-numeric: tabular-nums;
  }

  textarea {
    width: 100%;
    height: 400px;
    padding: 1.25rem;
    font-size: 0.95rem;
    font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
    background: var(--bg);
    border: none;
    color: var(--text);
    resize: vertical;
    line-height: 1.6;
  }

  textarea:focus {
    outline: none;
  }

  textarea::placeholder {
    color: var(--text-dim);
    opacity: 0.5;
  }

  #encrypted {
    color: var(--success);
    background: rgba(16, 185, 129, 0.03);
  }

  .stats-bar {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.25rem 1.5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 2rem;
  }

  .stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
  }

  .stat-label {
    font-size: 0.75rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
  }

  .stat-value.positive {
    color: var(--success);
  }

  .stat-value.negative {
    color: #ef4444;
  }

  .stat-value.neutral {
    color: var(--text-dim);
  }

  @media (max-width: 768px) {
    body {
      padding: 1rem;
    }

    h1 {
      font-size: 2rem;
    }

    .editor-grid {
      grid-template-columns: 1fr;
    }

    .stats-bar {
      flex-direction: column;
      gap: 1rem;
      display: none;
    }
  }
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>Encrypter</h1>
  </header>

  <div class="key-section">
    <label class="key-label" for="key">Encryption Key (Optional)</label>
    <input type="text" id="key" placeholder="Enter a password to encrypt the mapping...">
  </div>

  <div class="editor-grid">
    <div class="editor-panel">
      <div class="editor-header">
        <span class="editor-title">Original Text</span>
        <span class="editor-count" id="originalCount">0 characters</span>
      </div>
      <textarea id="original" placeholder="Type or paste your text here..."></textarea>
    </div>

    <div class="editor-panel">
      <div class="editor-header">
        <span class="editor-title">Encrypted Output</span>
        <span class="editor-count" id="encryptedCount">0 characters</span>
      </div>
      <textarea id="encrypted" placeholder="Symbols will appear here..."></textarea>
    </div>
  </div>

  <div class="stats-bar">
    <div class="stat">
      <span class="stat-label">Compression</span>
      <span class="stat-value neutral" id="compressionValue">0%</span>
    </div>
    <div class="stat">
      <span class="stat-label">Size Reduction</span>
      <span class="stat-value neutral" id="reductionValue">0 chars</span>
    </div>
  </div>
</div>

<script>
const originalBox = document.getElementById("original");
const encryptedBox = document.getElementById("encrypted");
const keyBox = document.getElementById("key");
const originalCount = document.getElementById("originalCount");
const encryptedCount = document.getElementById("encryptedCount");
const compressionValue = document.getElementById("compressionValue");
const reductionValue = document.getElementById("reductionValue");

// Enhanced Alphabet with more symbols for encoding
const normalAlphabet = 
  "abcdefghijklmnopqrstuvwxyz" +
  "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
  "0123456789" +
  " .,!?:;'\"-_=+()[]{}<>/@#$%&*\\|^~`\n";

// Enhanced Dictionary with more patterns for better compression
const baseWords = [
  // Common word pairs (bigrams)
  "the", "and", "ing", "ion", "tio", "ent", "ati", "for", "her", "ter", 
  "hat", "tha", "ere", "ate", "his", "con", "res", "ver", "all", "ons",
  "nce", "men", "ith", "ted", "ers", "pro", "thi", "wit", "are", "ess",
  "not", "ive", "was", "ect", "rea", "com", "eve", "per", "int", "est",
  "sta", "cti", "ica", "ist", "ear", "ain", "one", "our", "iti", "rat",
  
  // Common phrases and words
  "of the", "in the", "to the", "for the", "on the", "at the", "from the", "with the", "by the", "and the",
  "that the", "is the", "as the", "was the", "are the", "it is", "there is", "there are", "this is",
  "it was", "I am", "you are", "we are", "they are", "he is", "she is", "I have", "you have", "we have",
  "they have", "I will", "you will", "we will", "they will", "do not", "does not", "did not", "is not",
  "are not", "was not", "were not", "have not", "has not", "had not", "will not", "would not", "should not",
  "could not", "cannot", "can not", "I would", "you would", "he would", "she would", "we would", "they would",
  
  // Single letters with space
  "a ", "b ", "c ", "d ", "e ", "f ", "g ", "h ", "i ", "j ", "k ", "l ", "m ",
  "n ", "o ", "p ", "q ", "r ", "s ", "t ", "u ", "v ", "w ", "x ", "y ", "z ",
  "A ", "B ", "C ", "D ", "E ", "F ", "G ", "H ", "I ", "J ", "K ", "L ", "M ",
  "N ", "O ", "P ", "Q ", "R ", "S ", "T ", "U ", "V ", "W ", "X ", "Y ", "Z ",
  
  // Common punctuation patterns
  ". ", ", ", "; ", ": ", "! ", "? ", " - ", " (", ") ", "[ ", "] ", "{ ", "} ", 
  " '", "' ", " \"", "\" ", " `", "` ", " /", "\\ ", " |", " @", " #", " $", " %",
  
  // Common pairs/suffixes
  "ed ", "ing ", "ly ", "ment", "able", "tion", "ness", "less", "ful", "ive",
  "al ", "ic ", "ous", "ive", "ent", "ant", "ance", "ence", "ity", "ship",
  
  // Fixed-length encodings for common prefixes/suffixes
  "un", "re", "dis", "pre", "post", "anti", "sub", "over", "under", "super",
  
  // Special cases
  "the ", "and ", "for ", "you", "with", "this", "that", "have", "from", "they"
];

let dictionaryPatterns = [];
function addToDict(str) {
  if (!dictionaryPatterns.includes(str)) dictionaryPatterns.push(str);
}
baseWords.forEach(word => addToDict(word));
dictionaryPatterns.sort((a, b) => b.length - a.length);

// Enhanced Symbol Pool with more characters
function generateSymbols() {
  let syms = [];
  
  // Tibetan characters (compact)
  for(let i=0x0F00; i<=0x0FFF; i++) syms.push(String.fromCharCode(i));
  
  // Mathematical Operators
  for(let i=0x2200; i<=0x22FF; i++) syms.push(String.fromCharCode(i));
  
  // Geometric Shapes
  for(let i=0x25A0; i<=0x25FF; i++) syms.push(String.fromCharCode(i));
  
  // Box Drawing
  for(let i=0x2500; i<=0x257F; i++) syms.push(String.fromCharCode(i));
  
  // Miscellaneous Symbols
  for(let i=0x2600; i<=0x26FF; i++) syms.push(String.fromCharCode(i));
  
  // Dingbats
  for(let i=0x2700; i<=0x27BF; i++) syms.push(String.fromCharCode(i));
  
  // Supplemental Arrows
  for(let i=0x2900; i<=0x297F; i++) syms.push(String.fromCharCode(i));
  
  // Braille Patterns 
  for(let i=0x2800; i<=0x28FF; i++) syms.push(String.fromCharCode(i));
  
  // Additional symbols
  for(let i=0x4E00; i<=0x4FE0; i+=2) syms.push(String.fromCharCode(i));
  
  // Cyrillic Extended
  for(let i=0x2DE0; i<=0x2DFF; i++) syms.push(String.fromCharCode(i));
  
  // Ensure enough symbols for compression
  syms.push(..."∀∁∂∃∄∅∆∇∈∉∊∋∌∍∎∏∐∑−∓∔∕∖∗∘∙√∛∜∝∞∟∠∡∢∣∤∥∦∧∨∩∪∫∬∭∮∯∰∱∲∳∴∵∶∷∸∹∺∻∼∽∾∿≀≁≂≃≄≅≆≇≈≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩≪≫≬≭≮≯≰≱≲≳≴≵≶≷≸≹≺≻≼≽≾≿⊀⊁⊂⊃⊄⊅⊆⊇⊈⊉⊊⊋⊌⊍⊎⊏⊐⊑⊒⊓⊔⊕⊖⊗⊘⊙⊚⊛⊜⊝⊞⊟⊠⊡⊢⊣⊤⊥⊦⊧⊨⊩⊪⊫⊬⊭⊮⊯⊰⊱⊲⊳⊴⊵⊶⊷⊸⊹⊺⊻⊼⊽⊾⊿⋀⋁⋂⋃⋄⋅⋆⋇⋈⋉⋊⋋⋌⋍⋎⋏⋐⋑⋒⋓⋔⋕⋖⋗⋘⋙⋚⋛⋜⋝⋞⋟⋠⋡⋢⋣⋤⋥⋦⋧⋨⋩⋪⋫⋬⋭⋮⋯⋰⋱");
  
  // Greek and Coptic
  for(let i=0x0370; i<=0x03FF; i++) syms.push(String.fromCharCode(i));
  
  // Enclosed Alphanumerics
  for(let i=0x2460; i<=0x24FF; i++) syms.push(String.fromCharCode(i));
  
  return syms;
}

const allSymbols = generateSymbols();
let dictToSymbol = {};
let symbolToDict = {};
let singleCharMap = {};
let singleCharReverseMap = {};

function buildDictionaryMappings() {
  dictToSymbol = {};
  symbolToDict = {};
  
  // Assign symbols to dictionary patterns
  for (let i = 0; i < dictionaryPatterns.length && i < allSymbols.length; i++) {
    const pattern = dictionaryPatterns[i];
    const sym = allSymbols[i];
    dictToSymbol[pattern] = sym;
    symbolToDict[sym] = pattern;
  }
  
  // Assign symbols to individual characters for better compression
  singleCharMap = {};
  singleCharReverseMap = {};
  
  for (let i = 0; i < normalAlphabet.length; i++) {
    const symbolIndex = i + dictionaryPatterns.length;
    if (symbolIndex < allSymbols.length) {
      const char = normalAlphabet[i];
      const sym = allSymbols[symbolIndex];
      singleCharMap[char] = sym;
      singleCharReverseMap[sym] = char;
    }
  }
}

buildDictionaryMappings();

function makeRngFromKey(key) {
  let hash = 2166136261;
  for (const ch of key) {
    hash ^= ch.charCodeAt(0);
    hash = Math.imul(hash, 16777619);
  }
  return function() {
    hash ^= hash << 13; hash ^= hash >> 17; hash ^= hash << 5;
    return (hash >>> 0) / 4294967296;
  }
}

function shuffleMapping(key) {
  const rng = makeRngFromKey(key || "default-static-seed");
  
  // Create arrays from the mappings for shuffling
  const dictPatterns = Object.keys(dictToSymbol);
  const dictSymbols = dictPatterns.map(pattern => dictToSymbol[pattern]);
  
  const singleChars = Object.keys(singleCharMap);
  const singleSymbols = singleChars.map(char => singleCharMap[char]);
  
  // Fisher-Yates shuffle for dictionary mappings
  for (let i = dictPatterns.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [dictPatterns[i], dictPatterns[j]] = [dictPatterns[j], dictPatterns[i]];
    [dictSymbols[i], dictSymbols[j]] = [dictSymbols[j], dictSymbols[i]];
  }
  
  // Fisher-Yates shuffle for single character mappings
  for (let i = singleChars.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [singleChars[i], singleChars[j]] = [singleChars[j], singleChars[i]];
    [singleSymbols[i], singleSymbols[j]] = [singleSymbols[j], singleSymbols[i]];
  }
  
  // Rebuild mappings
  dictToSymbol = {};
  symbolToDict = {};
  for (let i = 0; i < dictPatterns.length; i++) {
    dictToSymbol[dictPatterns[i]] = dictSymbols[i];
    symbolToDict[dictSymbols[i]] = dictPatterns[i];
  }
  
  singleCharMap = {};
  singleCharReverseMap = {};
  for (let i = 0; i < singleChars.length; i++) {
    singleCharMap[singleChars[i]] = singleSymbols[i];
    singleCharReverseMap[singleSymbols[i]] = singleChars[i];
  }
}

function encrypt(text, key) {
  // Shuffle mappings based on key
  shuffleMapping(key);
  
  let output = [];
  let currentIndex = 0;
  
  while (currentIndex < text.length) {
    let matchedPattern = null;
    
    // Look for the longest matching pattern from the dictionary
    for (let pattern of dictionaryPatterns) {
      if (currentIndex + pattern.length <= text.length && 
          text.substring(currentIndex, currentIndex + pattern.length) === pattern) {
        matchedPattern = pattern;
        break;
      }
    }
    
    if (matchedPattern) {
      // Use dictionary mapping
      output.push(dictToSymbol[matchedPattern]);
      currentIndex += matchedPattern.length;
    } else {
      // Encode single character
      const currentChar = text[currentIndex];
      
      if (currentChar in singleCharMap) {
        // Use single character mapping
        output.push(singleCharMap[currentChar]);
      } else {
        // Character not in normalAlphabet, output as-is
        output.push(currentChar);
      }
      
      currentIndex++;
    }
  }
  
  return output.join('');
}

function decrypt(text, key) {
  // Shuffle mappings based on key (must be same as encryption)
  shuffleMapping(key);
  
  let output = [];
  let symbols = Array.from(text);
  
  for (let i = 0; i < symbols.length; i++) {
    const symbol = symbols[i];
    
    // First check if it's a dictionary pattern
    if (symbolToDict[symbol]) {
      output.push(symbolToDict[symbol]);
    } 
    // Then check if it's a single character mapping
    else if (singleCharReverseMap[symbol]) {
      output.push(singleCharReverseMap[symbol]);
    }
    // Otherwise output symbol as-is
    else {
      output.push(symbol);
    }
  }
  
  return output.join('');
}

let isUpdating = false;

function updateStats() {
  const origLen = originalBox.value.length;
  const encLen = encryptedBox.value.length;
  
  originalCount.textContent = `${origLen} character${origLen !== 1 ? 's' : ''}`;
  encryptedCount.textContent = `${encLen} character${encLen !== 1 ? 's' : ''}`;
  
  if (origLen > 0) {
    const savings = Math.round((1 - (encLen / origLen)) * 100);
    const reduction = origLen - encLen;
    
    if (reduction < 0 || savings < 0) {
      compressionValue.textContent = `${Math.abs(savings)}%`;
      compressionValue.className = 'stat-value negative';
      reductionValue.textContent = `+${Math.abs(reduction)}`;
      reductionValue.className = 'stat-value negative';
    } else {
      compressionValue.textContent = `${savings}%`;
      compressionValue.className = 'stat-value positive';
      reductionValue.textContent = `−${reduction}`;
      reductionValue.className = 'stat-value positive';
    }
  } else {
    compressionValue.textContent = '0%';
    compressionValue.className = 'stat-value neutral';
    reductionValue.textContent = '0';
    reductionValue.className = 'stat-value neutral';
  }
}

function updateFromOriginal() {
  if (isUpdating) return;
  
  try {
    isUpdating = true;
    const encrypted = encrypt(originalBox.value, keyBox.value);
    encryptedBox.value = encrypted;
    updateStats();
  } catch (error) {
    console.error("Encryption error:", error);
  } finally {
    isUpdating = false;
  }
}

function updateFromEncrypted() {
  if (isUpdating) return;
  
  try {
    isUpdating = true;
    const decrypted = decrypt(encryptedBox.value, keyBox.value);
    originalBox.value = decrypted;
    updateStats();
  } catch (error) {
    console.error("Decryption error:", error);
  } finally {
    isUpdating = false;
  }
}

originalBox.addEventListener("input", updateFromOriginal);
encryptedBox.addEventListener("input", updateFromEncrypted);
keyBox.addEventListener("input", updateFromOriginal);

window.addEventListener('load', () => {
  updateFromOriginal();
});
</script>
</body>
</html>
