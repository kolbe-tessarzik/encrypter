<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8"/>
<title>Competition Compressor — High Density (pako + tokenization + bitpack)</title>
<style>
  body{background:#071026;color:#e6eef6;font-family:system-ui,monospace;padding:20px}
  h1{margin:0 0 6px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  textarea,input{width:100%;padding:10px;border-radius:8px;border:1px solid #2a3b4f;background:#0b1a2b;color:#e6eef6;resize:vertical}
  label{font-size:13px;color:#9fb0c3}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px}
  .stats{margin-top:8px;color:#9fe9c7}
  button{padding:8px 12px;border-radius:8px;border:0;background:#2dd4bf;color:#042;font-weight:700;cursor:pointer}
  .small{font-size:13px;color:#9fb0c3}
  .muted{color:#86a0b6;font-size:13px}
  #loading { color:#ffd86b }
</style>

<body>
  <h1>Competition Compressor — High Density</h1>
  <div class="muted">Dictionary → pako.deflate → XOR (optional) → keyed bit-packing → compact Unicode output</div>

  <div style="margin-top:12px">
    <label>Key (optional — toggles keyed alphabet)</label>
    <input id="key" placeholder="passphrase (optional)">
  </div>

  <div style="height:12px;"></div>
  <div class="grid">
    <div>
      <label>Input (original)</label>
      <textarea id="input" placeholder="Paste original text here..." rows="18"></textarea>
      <div class="row">
        <button id="encodeBtn">Encode →</button>
        <div class="small muted">Auto encodes as you type</div>
      </div>
    </div>

    <div>
      <label>Output (compact)</label>
      <textarea id="output" placeholder="Compressed output appears here..." rows="18"></textarea>
      <div class="row">
        <button id="decodeBtn">Decode ←</button>
        <div class="small muted">Auto decodes when you edit output</div>
      </div>
    </div>
  </div>

  <div class="stats" id="stats">Initializing... <span id="loading">building alphabet — one moment</span></div>

  <!-- pako for compression -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

<script>
// ----------------- Configuration -----------------
const DICT = [
  " the "," and "," to "," of "," in "," that "," is "," for ",
  "ing","tion","ion","ed ","ly ","er ","re ","on ","th","he","in","er"
].sort((a,b)=>b.length-a.length);
// ensure DICT length <= 254 so our escape scheme fits
if (DICT.length > 254) throw new Error("DICT too large");

// We'll build a large printable charset once (cached)
let BLOCK_CHARS = null;
let BUILDING = true;

// ----------------- Utilities -----------------
const enc = new TextEncoder();
const dec = new TextDecoder();

// SHA-256 -> offset
async function sha256ToOffset(str, mod) {
  if (!str) return 0;
  const data = enc.encode(str);
  const digest = await crypto.subtle.digest("SHA-256", data);
  const dv = new DataView(digest);
  // use first 4 bytes
  return dv.getUint32(0) % mod;
}

// Build printable Unicode set once (skip whitespace, control, combining, surrogates)
function buildBlockChars() {
  if (BLOCK_CHARS) return BLOCK_CHARS;
  const out = [];
  // iterate through a wide range of codepoints; start at 0x21 (printable)
  // go up to 0x10FFFF — skip surrogates and undesirable categories
  const reCcCf = /[\p{Cc}\p{Cf}]/u;
  const reMnMe = /\p{Mn}|\p{Me}/u;
  for (let cp = 0x21; cp <= 0x10FFFF; cp++) {
    if (cp >= 0xD800 && cp <= 0xDFFF) { cp = 0xDFFF; continue; } // skip surrogates block efficiently
    try {
      const ch = String.fromCodePoint(cp);
      // skip whitespace (spaces, tabs, newlines, NBSP, etc.)
      if (/\s/.test(ch)) continue;
      if (reCcCf.test(ch)) continue;
      if (reMnMe.test(ch)) continue;
      out.push(ch);
    } catch (e) {
      // ignore invalid codepoints
    }
    // IMPORTANT: building ~1.1M codepoints can be slow; but we do it once.
    // If you want a faster startup, confine to a smaller range (e.g., 0x200..0xFFFD).
  }
  return out;
}

// keyed rotation of block chars
async function getKeyedChars(key) {
  if (!BLOCK_CHARS) BLOCK_CHARS = buildBlockChars();
  if (!key) return BLOCK_CHARS;
  const off = await sha256ToOffset(key, BLOCK_CHARS.length);
  // rotate
  return BLOCK_CHARS.slice(off).concat(BLOCK_CHARS.slice(0, off));
}

// ----------------- Tokenization (byte-level safe) -----------------
// We'll encode dictionary tokens into bytes using an escape byte 0xFF followed by index (0..253)
const ESC = 0xFF;

function tokenizeToBytes(str) {
  const out = [];
  let i = 0;
  while (i < str.length) {
    let matched = false;
    for (let j = 0; j < DICT.length; j++) {
      const d = DICT[j];
      if (str.startsWith(d, i)) {
        out.push(ESC, j); // ESC + index
        i += d.length;
        matched = true;
        break;
      }
    }
    if (matched) continue;
    const cp = str.codePointAt(i);
    const ch = String.fromCodePoint(cp);
    const bs = enc.encode(ch);
    for (const b of bs) out.push(b);
    i += ch.length;
  }
  return new Uint8Array(out);
}

function detokenizeFromBytes(bytes) {
  const resultBytes = [];
  for (let i = 0; i < bytes.length; i++) {
    const b = bytes[i];
    if (b === ESC) {
      if (i + 1 >= bytes.length) throw new Error("Truncated token stream");
      const idx = bytes[++i];
      if (idx >= DICT.length) throw new Error("Invalid token index");
      const chunk = enc.encode(DICT[idx]);
      for (const cb of chunk) resultBytes.push(cb);
    } else {
      resultBytes.push(b);
    }
  }
  return dec.decode(new Uint8Array(resultBytes));
}

// ----------------- Framing + XOR -----------------
function makeFrame(compressedBytes) {
  // 4-byte big-endian length (compressed length)
  const len = compressedBytes.length;
  const frame = new Uint8Array(4 + len);
  frame[0] = (len >> 24) & 0xFF;
  frame[1] = (len >> 16) & 0xFF;
  frame[2] = (len >> 8) & 0xFF;
  frame[3] = len & 0xFF;
  frame.set(compressedBytes, 4);
  return frame;
}

function readFrame(buf) {
  if (buf.length < 4) throw new Error("Frame too small");
  const len = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
  if (buf.length < 4 + len) throw new Error("Frame shorter than indicated length");
  return buf.slice(4, 4 + len);
}

function xorBytesWithKey(u8, keyStr) {
  if (!keyStr) return u8;
  const k = enc.encode(keyStr);
  if (k.length === 0) return u8;
  const out = new Uint8Array(u8.length);
  for (let i = 0; i < u8.length; i++) out[i] = u8[i] ^ k[i % k.length];
  return out;
}

// ----------------- Bitpack to keyed chars -----------------
function encodeBytesToChars(bytes, keyedChars) {
  // determine bits per output char
  const charsLen = BigInt(keyedChars.length);
  const bitsPerChar = Math.floor(Math.log2(keyedChars.length));
  if (bitsPerChar <= 0) throw new Error("charset too small");

  let buf = 0n;
  let bits = 0n;
  let out = "";

  const writeBits = (value, n) => {
    if (n === 0) return;
    buf = (buf << BigInt(n)) | BigInt(value & ((1 << n) - 1));
    bits += BigInt(n);
    while (bits >= BigInt(bitsPerChar)) {
      bits -= BigInt(bitsPerChar);
      const idx = Number((buf >> bits) & BigInt((1 << bitsPerChar) - 1));
      out += keyedChars[idx];
    }
  };

  for (let i = 0; i < bytes.length; i++) {
    writeBits(bytes[i], 8);
  }

  if (bits > 0n) {
    const pad = BigInt(bitsPerChar) - bits;
    // shift left to fill a full symbol (pad with zeros)
    const idx = Number((buf << pad) & BigInt((1 << bitsPerChar) - 1));
    out += keyedChars[idx];
  }

  return out;
}

function decodeCharsToBytes(str, keyedChars) {
  const map = Object.fromEntries(keyedChars.map((c, i) => [c, i]));
  const bitsPerChar = Math.floor(Math.log2(keyedChars.length));
  let buf = 0n;
  let bits = 0n;
  const out = [];

  // iterate codepoints (safe for surrogate pairs)
  for (let i = 0; i < str.length; ) {
    const code = str.codePointAt(i);
    const ch = String.fromCodePoint(code);
    i += ch.length;
    if (!(ch in map)) throw new Error("Invalid encoded character encountered during decode");
    const idx = BigInt(map[ch]);
    buf = (buf << BigInt(bitsPerChar)) | idx;
    bits += BigInt(bitsPerChar);
    while (bits >= 8n) {
      bits -= 8n;
      const byte = Number((buf >> bits) & 0xFFn);
      out.push(byte);
    }
  }
  return new Uint8Array(out);
}

// ----------------- Full encode / decode functions -----------------
async function compressAndEncode(text, key) {
  // 1) tokenize to bytes (escape tokens)
  const tokenBytes = tokenizeToBytes(text); // Uint8Array

  // 2) compress via pako (deflate)
  const compressed = pako.deflate(tokenBytes); // Uint8Array

  // 3) frame length + compressed
  const frame = makeFrame(compressed);

  // 4) XOR with key (applied to frame)
  const xored = xorBytesWithKey(frame, key);

  // 5) get keyed char set
  const keyed = await getKeyedChars(key || "");

  // 6) bitpack to chars
  const outStr = encodeBytesToChars(xored, keyed);
  return outStr;
}

async function decodeAndDecompress(str, key) {
  // 1) keyed char set
  const keyed = await getKeyedChars(key || "");

  // 2) bit-decode to bytes
  const bytes = decodeCharsToBytes(str, keyed);

  // 3) XOR with key (descramble)
  const descr = xorBytesWithKey(bytes, key);

  // 4) read frame length and extract compressed portion
  const compressedBytes = readFrame(descr);

  // 5) inflate (pako)
  const inflated = pako.inflate(compressedBytes);

  // 6) detokenize
  const out = detokenizeFromBytes(inflated);
  return out;
}

// ----------------- UI wiring -----------------
const inputEl = document.getElementById("input");
const outputEl = document.getElementById("output");
const keyEl = document.getElementById("key");
const statsEl = document.getElementById("stats");
const loadingSpan = document.getElementById("loading");
const encBtn = document.getElementById("encodeBtn");
const decBtn = document.getElementById("decodeBtn");

let suppress = false;
let initDone = false;

// Build the charset (async to avoid blocking UI)
setTimeout(async () => {
  loadingSpan.textContent = "building alphabet — this can take 1–3s depending on CPU";
  await new Promise(r => setTimeout(r, 50)); // let DOM update
  BLOCK_CHARS = buildBlockChars();
  loadingSpan.textContent = "alphabet ready";
  initDone = true;
  setTimeout(()=>loadingSpan.remove(), 900);
  // try initial conversion if input exists
  if (inputEl.value) debouncedEncode();
}, 10);

// debounce helpers
function debounce(fn, ms = 220) {
  let t;
  return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); };
}

async function doEncodeUI() {
  if (!initDone) { statsEl.textContent = "Still initializing alphabet — wait a moment."; return; }
  if (suppress) return;
  suppress = true;
  try {
    statsEl.textContent = "Encoding...";
    const key = keyEl.value || "";
    const out = await compressAndEncode(inputEl.value, key);
    outputEl.value = out;
    const o = inputEl.value.length;
    const e = out.length;
    const pct = o ? Math.round((1 - (e / o)) * 100) : 0;
    statsEl.textContent = `Original ${o} chars → Encoded ${e} chars · approx ${pct}% smaller`;
  } catch (err) {
    statsEl.textContent = "Encode error: " + (err && err.message ? err.message : String(err));
  } finally { suppress = false; }
}

async function doDecodeUI() {
  if (!initDone) { statsEl.textContent = "Still initializing alphabet — wait a moment."; return; }
  if (suppress) return;
  suppress = true;
  try {
    statsEl.textContent = "Decoding...";
    const key = keyEl.value || "";
    const out = await decodeAndDecompress(outputEl.value, key);
    inputEl.value = out;
    statsEl.textContent = `Decoded length: ${out.length} chars`;
  } catch (err) {
    statsEl.textContent = "Decode error: " + (err && err.message ? err.message : String(err));
  } finally { suppress = false; }
}

const debouncedEncode = debounce(doEncodeUI, 260);
const debouncedDecode = debounce(doDecodeUI, 260);

inputEl.addEventListener("input", debouncedEncode);
outputEl.addEventListener("input", debouncedDecode);
keyEl.addEventListener("input", () => { debouncedEncode(); debouncedDecode(); });
encBtn.addEventListener("click", doEncodeUI);
decBtn.addEventListener("click", doDecodeUI);

// quick helper: try initial decode if output is prefilled
window.addEventListener("load", () => {
  if (outputEl.value) debouncedDecode();
  else if (inputEl.value) debouncedEncode();
});

</script>
</body>
</html>
